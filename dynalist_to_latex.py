# -*- coding: utf-8 -*-
"""
Created on Sat Mar 21 18:39:05 2020

@author: benja
"""


import re
import networkx as nx

test_string = """Number Theory
    **2 Congruences**
        **Def Congruence** $$a \equiv b \;(n)$$ iff $$n | a-b$$ defines equivalence relation w/ set of equiv classes $$\Z / n\Z$$. $$n \Z$$ is an ideal to ring $$\Z$$; then $$\Z / n \Z$$ is the quotient ring
        **Lemma 2.1** TFAE 
            1. $$(a,n) = 1$$
            2. $$\exists b : ab \equiv 1 \; (n)$$, i.e. a has multiplicative inverse in $$\Z / n \Z$$
            3. a is a generator of group $$(\Z / n \Z, +)$$
        **Units** ... more text
"""

test_string2 = """Number Theory
    **0 Introduction**
        NT is about properties of integers and rationals.
    **1 Euclid's algorithm and factoring**
        **Def Division Algo** $$a, b \in \Z$$, $$b > 0$$ then $$a = bq +  r$$ with $$0 \leq r < b$$
            **Proof** r is least of $$\{ a - nb \geq 0 : n \in \Z \}$$
        $$I = \{ \lambda_1 a_1 + \cdots + \lambda_n a_n : \lambda_i \in \Z \}$$ is the ideal generated by $$\{a_1, \dots a_n\}$$
        **Lemma 1.1** $$I = d \Z$$ for some $$d \geq 1$$ unique
TEMPTEXT
            **Proof** Let d be least integer in I. Ideal $$ \implies d\Z \subset I$$, and div algo gives converse
        **Def gcd/hcf** $$d = gcd(a_1, \dots, a_n) = (a_1, \dots, a_n)$$
            $$I = < a_1, \dots, a_n>$$ then $$I = d\Z;\; d = gcd(a_1, \dots, a_n)$$"""
            
test_string3 = """test
    m1
        m2
        m3
m4
m5
        m6
    m7
        m8
m9
    
    
    m10
        m11"""
        

#TODO fix latex indentation limit - too highly nested itemization / enumerations.
        
def uber_conversion(instring):
    tabbed_list = convert_plaintext_to_latex(instring)
    tab_tree_root = lines_to_indent(tabbed_list)[0]
    display_list = display_tab_tree(tab_tree_root)
    return '\n'.join(display_list)

def convert_plaintext_to_latex(instring):
    lines = instring.split('\n')
    output = [lines[0]]
    for i in range(1, len(lines)):
        replacement = False
        while True:
            temp = lines[i]
            lines[i] = re.sub('^(\t*?)    ', r'\1\t', temp)
            if temp == lines[i]:
                if not replacement:
                    output[-1] += r'\\' + temp
                else:
                    output.append(temp)
                break
            replacement = True
            
    return output

def display_tab_tree(root):
    output = []
    if root.level == 0:
        for child in root.children:
            output += display_tab_tree(child)
        return output
    elif root.level == 1:
        output.append(r'\section{' + format_line(root.text) + '}')
        output.append(r'\begin{itemize}')
        for child in root.children:
            output += ['    ' + line for line in display_tab_tree(child)]
        output.append(r'\end{itemize}')
        return output
        
    elif root.level > 1:
        output.append(r'\item ' + format_line(root.text))
    
    if len(root.children) > 0:
        output.append(r'\begin{itemize}')
        for child in root.children:
            output += ['    ' + line for line in display_tab_tree(child)]
        output.append(r'\end{itemize}')
    return output
    
def format_line(line):
    # inline equation
    line = re.sub('[$][$]', '$', line)
    # bold font
    line = re.sub('[*][*](.*?)[*][*]', r'\\textbf{\1}', line)
    return line
        

class tab_tree:
    def __init__(self, level, text=None, parent=None):
        self.text = text
        self.level = level
        self.parent = parent
        self.children = []
        # why does self.children = children where children=None make children act like a class variable?
        


def lines_to_indent(lines):
    # G is for optional visualisation of tab_tree for debugging purposes
    root = tab_tree(0, text=lines[0])
    current = root
    G = nx.DiGraph()
    print(current.level)
    for line in lines[1:]:
        line_level = 0
        while len(line) > 0 and line[0] == '\t':
            line = line[1:]
            line_level += 1
            
        if line_level == current.level + 1:
            pass
        elif line_level <= current.level:
            for _ in range(current.level - line_level + 1):
                current = current.parent
            
        leaf = tab_tree(line_level, text=line, parent=current)
        current.children.append(leaf)
        G.add_edge(current.text, leaf.text)
        #print('before: {}:{}, {}'.format(current.level, current.text, str(len(current.children))))
        current = leaf
        #print('after: {}:{}, {}'.format(current.level, current.text, str(len(current.children))))
    return root, G



            
if __name__ == '__main__':
    idk = convert_plaintext_to_latex(test_string)
    idk2 = lines_to_indent(idk)
    print('\n'.join(display_tab_tree(idk2[0])))

